const { Telegraf } = require('telegraf');
const http = require('http');
const { User, Withdrawal } = require('./database');



const dotenv = require('dotenv');

// Charger les variables d'environnement depuis .env
dotenv.config();

// R√©cup√©rer les variables d'environnement
const BOT_TOKEN = process.env.BOT_TOKEN;
const ADMIN_ID = process.env.ADMIN_ID;

const bot = new Telegraf(BOT_TOKEN); // Utilisation du token depuis .env
const withdrawalProcess = new Map();




// Middleware de d√©bogage et gestion d'erreurs
bot.use(async (ctx, next) => {
  try {
    console.log(`Update re√ßu: ${JSON.stringify(ctx.update)}`);
    await next();
  } catch (error) {
    if (error.response?.error_code === 403 && error.response?.description.includes('blocked by the user')) {
      console.log(`‚ö†Ô∏è Utilisateur ${ctx.from?.id} a bloqu√© le bot. Suppression de l'utilisateur.`);
      await User.deleteOne({ id: ctx.from?.id });
    } else {
      console.error('‚ùå Erreur middleware:', error);
    }
  }
});

// Fonction utilitaire pour envoyer un message avec gestion d'erreur
async function sendMessage(chatId, text, options = {}) {
  try {
    await bot.telegram.sendMessage(chatId, text, options);
  } catch (err) {
    if (err.response && err.response.error_code === 403) {
      console.log(`‚ö†Ô∏è Utilisateur ${chatId} a bloqu√© le bot. Suppression de l'utilisateur de la base de donn√©es.`);
      await User.deleteOne({ id: chatId });
    } else {
      console.error(`‚ùå Erreur lors de l'envoi d'un message √† ${chatId} :`, err);
    }
  }
}

// V√©rifie si l'utilisateur est abonn√© aux deux canaux
async function isUserInChannels(userId) {
  try {
    const member1 = await bot.telegram.getChatMember('-1002017559099', userId);
    const member2 = await bot.telegram.getChatMember('-1002191790432', userId);
    return ['member', 'administrator', 'creator'].includes(member1.status) &&
           ['member', 'administrator', 'creator'].includes(member2.status);
  } catch (err) {
    console.error('‚ùå Erreur v√©rification canaux:', err);
    return false;
  }
}

// Enregistre l'utilisateur sans attribuer imm√©diatement la r√©compense au parrain
async function registerUser(userId, username, referrerId) {
  try {
    let user = await User.findOne({ id: userId });
    if (!user) {
      // On initialise joined_channels √† false pour que la r√©compense ne soit pas attribu√©e avant la v√©rification
      user = await User.create({ id: userId, username, referrer_id: referrerId, joined_channels: false });
      console.log(`‚úÖ Utilisateur ${userId} enregistr√©`);
    }
  } catch (err) {
    console.error('‚ùå Erreur enregistrement utilisateur:', err);
  }
}

// Met √† jour le solde de l'utilisateur selon le nombre d'invitations
async function updateUserBalance(userId) {
  const user = await User.findOne({ id: userId });
  if (user) {
    let bonus = 200;
    if (user.invited_count >= 10) {
      bonus = 300;
    } else if (user.invited_count >= 20) {
      bonus = 400;
    }
    await User.updateOne({ id: userId }, { balance: user.invited_count * bonus });
  }
}

// Notifie le parrain lors d'une inscription valid√©e via son lien
async function notifyReferrer(referrerId, newUserId) {
  try {
    await sendMessage(referrerId, `üéâ Un nouvel utilisateur (${newUserId}) s'est inscrit via votre lien de parrainage !`);
  } catch (err) {
    console.error('‚ùå Erreur notification parrain:', err);
  }
}

// Commande /start
bot.start(async (ctx) => {
  const userId = ctx.message.from.id;
  const username = ctx.message.from.username || 'Utilisateur';
  const referrerId = ctx.startPayload ? parseInt(ctx.startPayload) : null;

  await registerUser(userId, username, referrerId);

  await sendMessage(userId, `ùêÅùê¢ùêûùêßùêØùêûùêßùêÆùêû ùê¨ùêÆùê´ ùêÇùêöùê¨ùê°ùêóùêûùê•ùê¢ùê≠ùêûùêõùê®ùê≠ ùê•ùêû ùê©ùê•ùêöùê≠ùêüùê®ùê´ùê¶ùêû ùê™ùêÆùê¢ ùêØùêöùê¨ ùê≠ùêû ùêüùêöùê¢ùê´ùêû ùê†ùêöùê†ùêßùêûùê´ ùêùùêÆ ùêúùêöùê¨ùê° üí¥!\n Rejoignez les canaux pour debloquer ton acces:`, {
    reply_markup: {
      inline_keyboard: [
        [{ text: 'Canal 1', url: 'https://t.me/+z73xstC898s4N2Zk' }],
         [{ text: 'Canal 2', url: 'https://t.me/+z7Ri0edvkbw4MDM0' }],
        [{ text: 'Canal 3', url: 'https://t.me/+rSXyxHTwcN5lNWE0' }],
        [{ text: '‚úÖ V√©rifier', callback_data: 'check' }]
      ]
    }
  });
});


// V√©rification de l'abonnement aux canaux et attribution de la r√©compense si applicable
bot.action('check', async (ctx) => {
  const userId = ctx.from.id;
  const user = await User.findOne({ id: userId });

  if (!user) {
    return ctx.reply('‚ùå Utilisateur non trouv√©.');
  }

  if (await isUserInChannels(userId)) {
    if (!user.joined_channels) {
      await User.updateOne({ id: userId }, { joined_channels: true });
      // Attribution de la r√©compense au parrain si l'utilisateur poss√®de un referrer
      if (user.referrer_id) {
        await User.updateOne({ id: user.referrer_id }, { $inc: { invited_count: 1, tickets: 1 } });
        await updateUserBalance(user.referrer_id);
        await notifyReferrer(user.referrer_id, userId);
      }
    }

    // Construction du clavier principal
    let keyboard = [
      [{ text: 'Mon compte üí≥' }, { text: 'Inviterüì¢' }],
      [{ text: 'Play to win üé∞' }, { text: 'Withdrawalüí∏' }],
      [{ text: 'Supportüì©' }, { text: 'Tuto üìñ' }],
      [{ text: 'Tombola üéüÔ∏è' }]
    ];

    // Bouton Admin visible uniquement pour l'admin
    if (String(userId) === ADMIN_ID) {
      keyboard.push([{ text: 'Admin' }]);
    }

    ctx.reply('‚úÖ Acc√®s autoris√© !', {
      reply_markup: {
        keyboard: keyboard,
        resize_keyboard: true
      }
    });
  } else {
    ctx.reply('‚ùå Rejoignez les canaux d\'abord !');
  }
});

// Gestion des commandes textuelles de base
bot.hears(
  ['Mon compte üí≥', 'Inviterüì¢', 'Play to win üé∞', 'Withdrawalüí∏', 'Supportüì©', 'Tuto üìñ', 'Tombola üéüÔ∏è', 'Admin'],
  async (ctx) => {
    const userId = ctx.message.from.id;
    const user = await User.findOne({ id: userId });
    if (!user) return ctx.reply('‚ùå Utilisateur non trouv√©.');

    switch (ctx.message.text) {
      case 'Mon compte üí≥':
        return ctx.reply(`üí∞ Solde: ${user.balance} Fcfa\nüìà Invit√©s: ${user.invited_count}\nüéüÔ∏è Tickets: ${user.tickets}`);
      case 'Inviterüì¢':
        return ctx.reply(`‚ùùùôèùô™ ùôúùôñùôúùô£ùôöùôßùôñùô® ùüÆùü¨ùü¨ ùôÅùòæùôÅùòº ùô•ùô§ùô™ùôß ùôòùôùùôñùô¶ùô™ùôö ùô•ùôöùôßùô®ùô§ùô£ùô£ùôö ùô¶ùô™ùôö ùô©ùô™ ùôûùô£ùô´ùôûùô©ùôöùô®.‚ùû \n \n üîó Lien de parrainage : https://t.me/cashXelitebot?start=${userId} \n \n ‚ùùüîπ ùêàùêßùêØùê¢ùê≠ùêû ùê≠ùêûùê¨ ùêöùê¶ùê¢ùê¨ ùêûùê≠ ùê´ùêû√ßùê®ùê¢ùê¨ ùêÆùêßùêû ùê´√©ùêúùê®ùê¶ùê©ùêûùêßùê¨ùêû :\n \n‚úÖùüè √† ùüèùüé ùêöùê¶ùê¢ùê¨ ‚Üí ùüêùüéùüé ùêÖùêÇùêÖùêÄ ùê©ùêöùê´ ùê¢ùêßùêØùê¢ùê≠ùêöùê≠ùê¢ùê®ùêß\n‚úÖ ùüèùüé √† ùüêùüé ùêöùê¶ùê¢ùê¨ ‚Üí ùüëùüéùüé ùêÖùêÇùêÖùêÄ ùê©ùêöùê´ ùê¢ùêßùêØùê¢ùê≠ùêöùê≠ùê¢ùê®ùêß\n‚úÖ ùüêùüé ùêöùê¶ùê¢ùê¨ ùê®ùêÆ ùê©ùê•ùêÆùê¨ ‚Üí ùüíùüéùüé ùêÖùêÇùêÖùêÄ ùê©ùêöùê´ ùê¢ùêßùêØùê¢ùê≠ùêöùê≠ùê¢ùê®ùêß \n üì≤ ùêèùê•ùêÆùê¨ ùê≠ùêÆ ùê¢ùêßùêØùê¢ùê≠ùêûùê¨, ùê©ùê•ùêÆùê¨ ùê≠ùêÆ ùê†ùêöùê†ùêßùêûùê¨ ! üöÄüî•‚ùû`);
      case 'Play to win üé∞':
        return ctx.reply(`üéÆ Jouer ici : https://t.me/cashXelitebot/cash`);
      case 'Withdrawalüí∏':
        if (user.balance >= 10000) {
          withdrawalProcess.set(userId, { step: 'awaiting_payment_method' });
          return ctx.reply('üí∏ M√©thode de paiement :');
        } else {
          return ctx.reply('‚ùå Minimum 10 000 Fcfa');
        }
      case 'Supportüì©':
        return ctx.reply('üì© Contact : @Medatt00');
      case 'Tuto üìñ':
        return ctx.reply('üìñ Guide : https://t.me/gxgcaca');
      case 'Tombola üéüÔ∏è':
        return ctx.reply('üéüÔ∏è 1 invitation = 1 ticket');
      case 'Admin':
        if (String(ctx.message.from.id) === ADMIN_ID) {
          await ctx.replyWithMarkdown('üîß *Menu Admin*', {
            reply_markup: {
              inline_keyboard: [
                [{ text: 'üë• Total Utilisateurs', callback_data: 'admin_users' }],
                [{ text: 'üìÖ Utilisateurs/mois', callback_data: 'admin_month' }],
                [{ text: 'üì¢ Diffuser message', callback_data: 'admin_broadcast' }]
              ]
            }
          });
        } else {
          return ctx.reply('‚ùå Acc√®s refus√©. Vous n\'√™tes pas administrateur.');
        }
        break;
    }
  }
);

// Commande /admin (alternative via commande)
bot.command('admin', async (ctx) => {
  if (String(ctx.from.id) !== ADMIN_ID) {
    return ctx.reply('‚ùå Acc√®s refus√©. Vous n\'√™tes pas administrateur.');
  }
  await ctx.replyWithMarkdown('üîß *Menu Admin*', {
    reply_markup: {
      inline_keyboard: [
        [{ text: 'üë• Total Utilisateurs', callback_data: 'admin_users' }],
        [{ text: 'üìÖ Utilisateurs/mois', callback_data: 'admin_month' }],
        [{ text: 'üì¢ Diffuser message', callback_data: 'admin_broadcast' }]
      ]
    }
  });
});
bot.command('send', async (ctx) => {
  if (String(ctx.from.id) !== ADMIN_ID) {
    return ctx.reply('‚ùå Acc√®s refus√©. Vous n\'√™tes pas administrateur.');
  }

  // D√©tection du type de m√©dia et r√©cup√©ration du file_id
  const mediaTypes = ['photo', 'video', 'document', 'audio', 'sticker', 'voice', 'video_note'];
  let mediaType = null;
  let mediaFileId = null;

  for (const type of mediaTypes) {
    if (ctx.message[type]) {
      mediaType = type;
      if (type === 'photo') {
        mediaFileId = ctx.message.photo[ctx.message.photo.length - 1].file_id;
      } else {
        mediaFileId = ctx.message[type].file_id;
      }
      break;
    }
  }

  // R√©cup√©ration du texte (depuis le message ou la l√©gende)
  const sourceText = ctx.message.text || ctx.message.caption || '';
  const messageToSend = sourceText.split(' ').slice(1).join(' ');

  // Validation si pas de m√©dia
  if (!mediaType && !messageToSend) {
    return ctx.reply('Veuillez fournir un message ou un m√©dia avec l√©gende. Exemple: /send Votre message ici');
  }

  const users = await User.find().select('id');
  let successCount = 0;

  for (const user of users) {
    try {
      if (mediaType) {
        const options = { caption: messageToSend };
        switch (mediaType) {
          case 'photo':
            await bot.telegram.sendPhoto(user.id, mediaFileId, options);
            break;
          case 'video':
            await bot.telegram.sendVideo(user.id, mediaFileId, options);
            break;
          case 'document':
            await bot.telegram.sendDocument(user.id, mediaFileId, options);
            break;
          case 'audio':
            await bot.telegram.sendAudio(user.id, mediaFileId, options);
            break;
          case 'voice':
            await bot.telegram.sendVoice(user.id, mediaFileId, options);
            break;
          case 'sticker':
            await bot.telegram.sendSticker(user.id, mediaFileId);
            if (messageToSend) await bot.telegram.sendMessage(user.id, messageToSend);
            break;
          case 'video_note':
            await bot.telegram.sendVideoNote(user.id, mediaFileId);
            if (messageToSend) await bot.telegram.sendMessage(user.id, messageToSend);
            break;
          default:
            break;
        }
      } else {
        await bot.telegram.sendMessage(user.id, messageToSend);
      }
      successCount++;
    } catch (error) {
      console.error(`Erreur envoi √† ${user.id}:`, error.message);
    }
  }

  await ctx.reply(`‚úÖ Message diffus√© √† ${successCount}/${users.length} utilisateurs.`);
});
// Processus de retrait via messages texte
bot.on('text', async (ctx) => {
  const userId = ctx.message.from.id;
  const userState = withdrawalProcess.get(userId);
  if (!userState) return;

  const user = await User.findOne({ id: userId });
  if (!user) {
    withdrawalProcess.delete(userId);
    return ctx.reply('‚ùå Utilisateur non trouv√©');
  }

  switch (userState.step) {
    case 'awaiting_payment_method':
      userState.paymentMethod = ctx.message.text;
      userState.step = 'awaiting_country';
      await ctx.reply('üåç Pays de r√©sidence :');
      break;
    case 'awaiting_country':
      userState.country = ctx.message.text;
      userState.step = 'awaiting_phone';
      await ctx.reply('üìû T√©l√©phone (avec indicatif) :');
      break;
    case 'awaiting_phone':
      userState.phone = ctx.message.text;
      userState.step = 'awaiting_email';
      await ctx.reply('üìß Email :');
      break;
    case 'awaiting_email':
      userState.email = ctx.message.text;
      const withdrawal = new Withdrawal({
        userId,
        amount: user.balance,
        ...userState
      });
      await withdrawal.save();

      await ctx.reply('‚úÖ Demande enregistr√©e !');
      await sendMessage(
        ADMIN_ID,
        `üí∏ Nouveau retrait\n\n` +
        `üë§ Utilisateur: @${ctx.from.username || 'N/A'}\n` +
        `üí∞ Montant: ${user.balance} Fcfa\n` +
        `üì± M√©thode: ${userState.paymentMethod}\n` +
        `üåç Pays: ${userState.country}\n` +
        `üìû T√©l: ${userState.phone}\n` +
        `üìß Email: ${userState.email}`
      );
      withdrawalProcess.delete(userId);
      break;
  }
});

// Gestion des callbacks admin pour statistiques et diffusion
const broadcastState = new Map();
bot.on('callback_query', async (ctx) => {
  const userId = String(ctx.from.id);
  const data = ctx.callbackQuery.data;

  if (userId === ADMIN_ID) {
    try {
      if (data === 'admin_users') {
        const count = await User.countDocuments();
        await ctx.replyWithMarkdown(`üë• *Total utilisateurs:* ${count}`);
      } else if (data === 'admin_month') {
        const start = new Date(new Date().getFullYear(), new Date().getMonth(), 1);
        const count = await User.countDocuments({ createdAt: { $gte: start } });
        await ctx.replyWithMarkdown(`üìÖ *Ce mois-ci:* ${count}`);
      } else if (data === 'admin_broadcast') {
        broadcastState.set(userId, { step: 'awaiting_message' });
        await ctx.reply('üì§ Envoyez le message √† diffuser :');
      } else if (data === 'broadcast_cancel') {
        broadcastState.delete(userId);
        await ctx.reply('Diffusion annul√©e.');
      } else if (data.startsWith('broadcast_')) {
        const [_, chatId, messageId] = data.split('_');
        const users = await User.find().select('id');
        let success = 0;
        await ctx.reply(`D√©but diffusion √† ${users.length} utilisateurs...`);
        for (const user of users) {
          try {
            await bot.telegram.copyMessage(user.id, chatId, messageId);
            success++;
          } catch (error) {
            console.error(`√âchec √† ${user.id}:`, error.message);
          }
        }
        await ctx.reply(`‚úÖ Diffusion termin√©e : ${success}/${users.length} r√©ussis`);
      }
    } catch (error) {
      console.error('Erreur admin:', error);
      await ctx.reply('‚ùå Erreur de traitement');
    }
  }
  await ctx.answerCbQuery();
});

// Gestion globale des erreurs
bot.catch((err, ctx) => {
  console.error(`‚ùå Erreur pour ${ctx.updateType}:`, err);
});

// D√©marrage du bot et cr√©ation du serveur HTTP
bot.launch()
  .then(() => console.log('üöÄ Bot d√©marr√© !'))
  .catch(err => {
    console.error('‚ùå Erreur de d√©marrage:', err);
    process.exit(1);
  });

http.createServer((req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.end('Bot en ligne');
}).listen(8080);
